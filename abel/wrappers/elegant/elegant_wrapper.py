# This file is part of ABEL
# Copyright 2025, The ABEL Authors
# Authors: C.A.Lindstrøm(1), J.B.B.Chen(1), O.G.Finnerud(1), D.Kalvik(1), E.Hørlyk(1), A.Huebl(2), K.N.Sjobak(1), E.Adli(1)
# Affiliations: 1) University of Oslo, 2) LBNL
# License: GPL-3.0-or-later

import uuid, os, subprocess, csv, shutil
import numpy as np
from abel.CONFIG import CONFIG
from abel.classes.beam import Beam
import scipy.constants as SI


def elegant_run(filename, beam0, inputbeamfile, outputbeamfile, verbose=False, tmpfolder=None, runnable=None, save_beams=True):
    """
    Run an ELEGANT simulation with an ABEL ``Beam`` object as input and return 
    the output beam.

    This function converts an ABEL ``Beam`` into an ELEGANT-compatible SDDS 
    input file, executes an ELEGANT simulation, and then converts the resulting
    SDDS output back into an ABEL ``Beam``. Metadata from the input beam is
    preserved and propagated to the output beam.

    Parameters
    ----------
    filename : str
        Path to the ELEGANT input file (``runfile.ele``).

    beam0 : ``Beam``
        Input beam.

    inputbeamfile : str
        Path to the temporary SDDS file that will store the input beam for 
        ELEGANT.

    outputbeamfile : str
        Path to the SDDS file generated by ELEGANT containing the output beam.
    
    verbose : bool
        If ``False``, suppress ELEGANT console output. Defaults to ``False``.
    
    tmpfolder : str, optional
        Temporary folder for intermediate files. If not provided, a new folder
        is created and cleaned up automatically.

    runnable : ``Runnable``, optional
        The ``Runnable`` object used for the run

    save_beams : bool
        Save beam evolution throughout lattice. Defaults to ``True``.

    Returns
    -------
    beam : ``Beam``
        Contains the output particle distribution after the ELEGANT run. 
        Metadata such as location, trackable number, stage number, and 
        per-particle charge are transferred from the input beam.

    evolution : list of ``Beam``
        Contains the output beams saved throughout the lattice.

    References
    ----------
    .. [1] ELEGANT Documentation: https://ops.aps.anl.gov/manuals/elegant_latest/elegant.html
    """
    
    # convert incoming beam object to temporary SDDS file
    elegant_write_beam(beam0, inputbeamfile, tmpfolder=tmpfolder)

    # make evolution folder
    evolution_folder = tmpfolder + 'evolution' + os.sep
    os.mkdir(evolution_folder)

    # run system command
    cmd = CONFIG.elegant_exec + 'elegant ' + filename + CONFIG.elegant_rpnflag
    if verbose:
        stdout = subprocess.DEVNULL
    else:
        stdout = None
    subprocess.call(cmd, shell=True, stdout=stdout)
    
    # convert SDDS output to beam object
    beam = elegant_read_beam(outputbeamfile, tmpfolder=tmpfolder, model_beam=beam0)
    beam.location = beam0.location
    
    # save evolution
    evolution = extract_beams_and_evolution(tmpfolder, evolution_folder, runnable, save_beams=save_beams, model_beam=beam0)
    
    return beam, evolution


# ==================================================
def elegant_read_beam(filename, tmpfolder=None, model_beam=None):
    """
    Convert an ELEGANT beam file (SDDS format) into an ABEL ``Beam`` object.

    This function uses the ELEGANT ``sdds2stream`` utility to extract particle 
    phase space data and beam charge from an SDDS file. The data is then mapped 
    into an ABEL ``Beam`` object, with proper coordinate transformations 
    (including a flipped z-coordinate) and energy conversion from Lorentz factor 
    (gamma).

    Parameters
    ----------
    filename : str
        Path to the input ELEGANT SDDS beam file.

    tmpfolder : str, optional
        Temporary folder used to store intermediate files. If not provided, a 
        new temporary folder will be created and deleted automatically.

    model_beam : ``Beam``, optional
        Beam from which metadata and charge is copied.

    Returns
    -------
    ``Beam`` or None
        An ABEL ``Beam`` object containing the phase space and beam charge.
        Returns ``None`` if the charge parameter cannot be extracted.

    References
    ----------
    .. [1] ELEGANT Documentation: https://ops.aps.anl.gov/manuals/elegant_latest/elegant.html
    """
    
    from abel.utilities.relativity import gamma2energy
    
    make_new_tmpfolder = tmpfolder is None
    if make_new_tmpfolder:
        tmpfolder = CONFIG.temp_path + str(uuid.uuid4())
        os.mkdir(tmpfolder)
    tmpfile =  tmpfolder + '/stream_' + str(uuid.uuid4()) + '.tmp'
    
    # convert SDDS file to CSV file
    subprocess.run(CONFIG.elegant_exec + 'sdds2stream ' + filename + ' -columns=x,xp,y,yp,t,p,dt > ' + tmpfile, shell=True)
    
    # extract charge
    Qabs = float(subprocess.check_output([CONFIG.elegant_exec + 'sdds2stream ' + filename + ' -parameter=Charge'], shell=True))
    if model_beam is not None:
        Q = abs(Qabs)*model_beam.charge_sign()
    else:
        Q = -abs(Qabs)
    
    # load phasespace from CSV file
    phasespace = np.loadtxt(open(tmpfile, "rb"), delimiter=' ')
    
    # delete CSV file and temporary folder
    os.remove(tmpfile)
    if make_new_tmpfolder:
        shutil.rmtree(tmpfolder)
    
    # make beam (note: z is flipped)
    beam = Beam()
    beam.set_phase_space(xs=phasespace[:,0], 
                       ys=phasespace[:,2], 
                       zs=-1*phasespace[:,6]*SI.c, 
                       xps=phasespace[:,1], 
                       yps=phasespace[:,3], 
                       Es=gamma2energy(phasespace[:,5]),
                       Q=Q) # TODO: deal with non-uniform weight particles
    beam.location = np.mean(phasespace[:,4])*SI.c
    
    # copy previous beam metadata
    if model_beam is not None:
        beam.location += model_beam.location
        beam.trackable_number = model_beam.trackable_number
        beam.stage_number = model_beam.stage_number
        beam.copy_particle_charge(model_beam) # forces charge preservation (TODO: improve this)
    
    return beam


# ==================================================
def elegant_write_beam(beam, filename, tmpfolder=None):
    """
    Convert an ABEL ``Beam`` object into an ELEGANT SDDS beam file.

    This function takes the phase space data stored in an ABEL ``Beam`` and 
    exports it into ELEGANT-compatible SDDS format. The data is first written to 
    a temporary CSV file, converted to SDDS (ASCII), metadata headers are 
    inserted, and finally converted into a binary SDDS file. Temporary files and 
    directories are removed unless explicitly provided.

    Parameters
    ----------
    beam : ``Beam``
        An ABEL ``Beam`` object containing particle phase space data.

    filename : str
        Path to the output ELEGANT SDDS file.

    tmpfolder : str, optional
        Path to a temporary folder for intermediate files. If not provided, a 
        new temporary folder will be created and deleted automatically.

    Returns
    -------
    str
        The path to the generated ELEGANT SDDS beam file.

    References
    ----------
    .. [1] ELEGANT Documentation: https://ops.aps.anl.gov/manuals/elegant_latest/elegant.html
    """
    
    from abel.utilities.relativity import energy2gamma
    
    # create temporary CSV file and folder
    make_new_tmpfolder = tmpfolder is None
    if make_new_tmpfolder:
        tmpfolder = CONFIG.temp_path + str(uuid.uuid4()) + '/'
        os.mkdir(tmpfolder)
    tmpfile = tmpfolder + 'beam_' + str(uuid.uuid4()) + '.csv'
    
    # write beam phasespace to CSV (note: z/t is flipped)
    M = np.matrix([beam.xs(),beam.xps(),beam.ys(),beam.yps(),-1*beam.ts(),beam.gammas(),beam.ts()])
    with open(tmpfile, 'w') as f:
        csvwriter = csv.writer(f, delimiter=',')
        for i in range(int(len(beam))):
            csvwriter.writerow([M[0,i], M[1,i], M[2,i], M[3,i], M[4,i], M[5,i], M[6,i], int(i+1)])
    
    # convert CSV to SDDS (ascii for now)
    subprocess.call(CONFIG.elegant_exec + 'csv2sdds ' + tmpfile + ' ' + filename + 
                        ' -asciiOutput -columnData=name=x,type=double,units=m' +
                        ' -columnData=name=xp,type=double' + 
                        ' -columnData=name=y,type=double,units=m' + 
                        ' -columnData=name=yp,type=double' + 
                        ' -columnData=name=t,type=double,units=s' + 
                        ' -columnData=name=p,type=double,units=\"m\$be\$nc\"' +
                        ' -columnData=name=dt,type=double,units=s' +
                        ' -columnData=name=particleID,type=ulong64', shell=True)
    
    # add metadata
    with open(filename, 'r') as f:
        lines = f.readlines()

        line1 = 2
        lines.insert(line1, '&parameter name=SVNVersion, description="SVN version number", type=string, &end\n')
        lines.insert(line1, '&parameter name=IDSlotsPerBunch, description="Number of particle ID slots reserved to a bunch", type=long, &end\n')
        lines.insert(line1, '&parameter name=Particles, description="Number of particles before sampling", type=long, &end\n')
        lines.insert(line1, '&parameter name=Charge, units=C, description="Bunch charge before sampling", type=double, &end\n')
        lines.insert(line1, '&parameter name=pCentral, symbol="p$bcen$n", units="m$be$nc", description="Reference beta*gamma", type=double, &end\n')
        lines.insert(line1, '&parameter name=Step, description="Simulation step", type=long, &end\n')
        
        line2 = 18
        lines.insert(line2, '28584M'+'\n')
        lines.insert(line2, str(int(len(beam)))+'\n')
        lines.insert(line2, str(int(len(beam)))+'\n')
        lines.insert(line2, ' '+str(beam.charge())+'\n')
        lines.insert(line2, ' '+str(energy2gamma(beam.energy()))+'\n')
        lines.insert(line2, str(1)+'\n')
    
        with open(filename, 'w') as f:
            f.write("".join(lines))
        
    # convert SDDS to binary
    subprocess.run(CONFIG.elegant_exec + 'sddsconvert -binary ' + filename + ' -noWarnings', shell=True)
    
    # delete CSV file and temporary folder
    os.remove(tmpfile)
    if make_new_tmpfolder:
        shutil.rmtree(tmpfolder)
    
    return filename
    

# ==================================================
def extract_beams_and_evolution(tmpfolder, evolution_folder, runnable=None, save_beams=True, model_beam=None):
    """
    Extract evolution data of various beam parameters and save snapshots of the 
    beam along the lattice.

    Parameters
    ----------
    tmpfolder : str
        Temporary run directory path containing diagnostic output files from the
        simulation (e.g. ``centroid_vs_s.cen``).

    evolution_folder : str
        Path to the directory containing beam files to extract beam parameter 
        evolution from.

    runnable : ``Runnable``, optional
        ABEL ``Runnable`` object. If provided and ``save_beams`` is ``True``, 
        the beam files are saved to the shot directory specified by 
        ``runnable.shot_path()``.

    save_beams : bool, optional
        If ``True`` and ``runnable`` is not ``None``, saves each extracted beam 
        snapshot to the shot directory specified by ``runnable.shot_path()``.
        Defaults to ``True``.

    model_beam : ``Beam``, optional
        Beam from which metadata and charge is copied.


    Returns
    -------
    evol : :class:`types.SimpleNamespace`
        Object containing arrays of beam parameters as a function of propagation 
        distance ``s``. Each field represents one beam parameter, e.g. 
        ``evol.emit_nx``, ``evol.bunch_length``, etc.
	
	
    References
    ----------
    .. [1] ELEGANT Documentation: https://ops.aps.anl.gov/manuals/elegant_latest/elegant.html
    """
    
    insitu_path = tmpfolder + 'diags/insitu/'

    # prepare data structure
    from types import SimpleNamespace
    evol = SimpleNamespace()
    
    # run system command for converting .cen file to a .csv file
    cmd = CONFIG.elegant_exec + '/sdds2stream ' + tmpfolder + '/centroid_vs_s.cen -columns=s,Cx,Cy,Cxp,Cyp,Cs,Cdelta,Particles,pCentral,Charge,ElementName,ElementType,ElementOccurence >' + tmpfolder + '/centroids.csv'
    subprocess.call(cmd, shell=True)

    # load centroid data from .csv file. All quantities in SI units unless otherwise specified.
    file = open(tmpfolder + '/centroids.csv', "rb")
    data = np.loadtxt(file, delimiter=' ', usecols=range(10))  # Avoids extracting the columns containing strings such as ElementName.
    file.close()

    # make mask to only extract at monitor locations
    file = open(tmpfolder + '/centroids.csv', "rb")
    names = np.loadtxt(file, usecols=10, dtype='str')  # Avoids extracting the columns containing strings such as ElementName.
    file.close()
    mask = (names=='MONITOR')
    evol.location = data[mask,0]
    evol.x = data[mask,1]
    evol.y = data[mask,2]
    evol.xp = data[mask,3]
    evol.yp = data[mask,4]
    evol.z = data[mask,5]
    evol.energy = data[mask,8]*(1+data[mask,6])*SI.m_e*SI.c**2/SI.e  # [eV]
    evol.charge = data[mask,9]
    
    # extract from beam
    evol.beam_size_x = np.empty_like(evol.location)
    evol.beam_size_y = np.empty_like(evol.location)
    evol.beta_x = np.empty_like(evol.location)
    evol.beta_y = np.empty_like(evol.location)
    evol.dispersion_x = np.empty_like(evol.location)
    evol.dispersion_y = np.empty_like(evol.location)
    evol.bunch_length = np.empty_like(evol.location)
    evol.emit_nx = np.empty_like(evol.location)
    evol.emit_ny = np.empty_like(evol.location)
    evol.rel_energy_spread = np.empty_like(evol.location)
    
    for i, file in enumerate(sorted(os.listdir(evolution_folder))):

        # extract the beam
        beam_step = elegant_read_beam(evolution_folder + os.fsdecode(file), tmpfolder=tmpfolder, model_beam=model_beam)

        # save beam parameters
        evol.beam_size_x[i] = beam_step.beam_size_x()
        evol.beam_size_y[i] = beam_step.beam_size_y()
        evol.beta_x[i] = beam_step.beta_x()
        evol.beta_y[i] = beam_step.beta_y()
        evol.dispersion_x[i] = beam_step.dispersion_x()
        evol.dispersion_y[i] = beam_step.dispersion_y()
        evol.bunch_length[i] = beam_step.bunch_length()
        evol.emit_nx[i] = beam_step.norm_emittance_x()
        evol.emit_ny[i] = beam_step.norm_emittance_y()
        evol.rel_energy_spread[i] = beam_step.rel_energy_spread()
        
        # save beams if requested
        if save_beams:
            if runnable is None:
                raise ValueError('runnable not provided.')
            beam_step.save(runnable=runnable)
            
    return evol
    

# ==================================================
def elegant_apl_fieldmap2D(tau_lens, lensdim_x=2e-3, lensdim_y=2e-3, lens_x_offset=0.0, lens_y_offset=0.0, tmpfolder=None):
    """
    Generates a 2D magnetic field map for an APL (Active Plasma Lens) and export 
    it in ELEGANT-compatible SDDS format.

    This function computes a 2D transverse magnetic field map (Bx, By) across a 
    rectangular region defined by the lens dimensions. The map is written to a 
    temporary CSV file, converted into an SDDS dataset, and returned as a binary 
    SDDS file for use in ELEGANT.

    Parameters
    ----------
    tau_lens : float
        Plasma lens parameter that determines the strength and nonlinearities of 
        the transverse field.
    
    lensdim_x : [m] float
        Half-width of the transverse field map in the x-direction. Defaults to 
        2e-3.

    lensdim_y : [m] float
        Half-width of the transverse field map in the y-direction. Defaults to 
        2e-3.
        
    lens_x_offset : [m] float
        Lens transverse offset in x. Defaults to 0.0.

    lens_y_offset : [m] float
        Lens transverse offset in y. Defaults to 0.0.

    tmpfolder : str, optional
        Temporary folder for intermediate CSV storage. If not provided, a new 
        folder will be created automatically.

    Returns
    -------
    filename : str
        The path to the generated ELEGANT SDDS field map file.
    """
    
    # transverse dimensions
    xs = np.linspace(-lensdim_x, lensdim_x, 501)
    ys = np.linspace(-lensdim_y, lensdim_y, 501)

    X, Y = np.meshgrid(xs, ys, indexing="xy")  # Shape: (len(ys), len(xs))
    Xo = X + lens_x_offset
    Yo = Y + lens_y_offset

    Bx = Yo + Xo * Yo * tau_lens
    By = -(Xo + ((Xo**2 + Yo**2) / 2) * tau_lens)

    # create map
    Bmap = np.column_stack((X.ravel(), Y.ravel(), Bx.ravel(), By.ravel()))
    
    # make temporary CSV file
    make_new_tmpfolder = tmpfolder is None
    if make_new_tmpfolder:
        tmpfolder = os.path.join(CONFIG.temp_path, str(uuid.uuid4()))
        os.mkdir(tmpfolder)
    tmpfile = os.path.join(tmpfolder, 'Bmap.csv')
       
    # save map to temp file
    np.savetxt(tmpfile, Bmap, delimiter=',')
    
    # convert SDDS to binary
    filename = os.path.join(tmpfolder, 'Bmap.sdds')
    subprocess.call(CONFIG.elegant_exec + 'csv2sdds ' + tmpfile + ' ' + filename + 
                        ' -columnData=name=x,type=double,unit=m' +
                        ' -columnData=name=y,type=double,unit=m' +
                        ' -columnData=name=Bx,type=double,unit=T' +
                        ' -columnData=name=By,type=double,unit=T', shell=True)
    
    # delete temporary CSV file and folder
    if make_new_tmpfolder:
        shutil.rmtree(tmpfolder)

    return filename
    