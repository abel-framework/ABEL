# This file is part of ABEL
# Copyright 2025, The ABEL Authors
# Authors: C.A.Lindstrøm(1), J.B.B.Chen(1), O.G.Finnerud(1), D.Kalvik(1), E.Hørlyk(1), A.Huebl(2), K.N.Sjobak(1), E.Adli(1)
# Affiliations: 1) University of Oslo, 2) LBNL
# License: GPL-3.0-or-later

from abc import abstractmethod
from abel.classes.trackable import Trackable
from abel.classes.cost_modeled import CostModeled
from types import SimpleNamespace
import numpy as np
import scipy.constants as SI
from abel.utilities.beam_physics import generate_trace_space
from abel.utilities.relativity import energy2gamma

class Source(Trackable, CostModeled):
    """
    Abstract base class representing particle beam sources.

    The ``Source`` class defines shared parameters and functionality for 
    generating particle distributions or simulating a particle beam source.

    Attributes
    ----------
    length : [m] float
        Physical length of the source component

    energy : [eV] float
        Nominal mean beam particle energy.

    charge : [C] float
        Total beam charge.

    accel_gradient : [V/m] float
        Acceleration gradient. If provided, ``Source.get_length()`` will compute 
        source length as ``energy / accel_gradient``.

    wallplug_efficiency : float
        Efficiency factor used when converting beam energy usage to wallplug
        energy usage.

    x_offset, y_offset : [m] float
        Transverse centroid offsets applied to the beam.

    x_angle, y_angle : [rad] float
        Transverse angular offsets applied to the beam.

    norm_jitter_emittance_x, norm_jitter_emittance_y : [m rad] float
        Used to generate jitter in position and angle by samling from a jitter 
        phase space defined by Twiss functions and the given emittance jitter.

    waist_shift_x, waist_shift_y : [m] float
        Multiplicative factor applied to shift the location of the waist. 
        Particle x and y coordinates are modified by subtracting 
        ``waist_shift_x * x'`` and ``waist_shift_y * y'`` respectively.

    jitter : SimpleNamespace
        Container for jitter scales with fields:
            x, y, z      (position jitter scales)
            t            (time jitter scale)
            xp, yp       (angular jitter scales)
            E            (energy jitter scale)

    spin_polarization : float
        Spin polarization magnitude. Mean value of projection in the defined 
        direction ``spin_polarization_direction``.

    spin_polarization_direction : str
        Defines the orientation of the spin. Can be ``'x'``, ``'y'`` or ``'z'``.

    is_polarized : bool
        Whether the source produces polarized particles.
    """
    #TODO: Why is accel_gradient needed??
    
    @abstractmethod
    def __init__(self, length=0, charge=None, energy=None, accel_gradient=None, wallplug_efficiency=1, x_offset=0, y_offset=0, x_angle=0, y_angle=0, norm_jitter_emittance_x=None, norm_jitter_emittance_y=None, waist_shift_x=0, waist_shift_y=0, rep_rate_trains=None, num_bunches_in_train=None, bunch_separation=None):

        super().__init__(num_bunches_in_train=num_bunches_in_train, bunch_separation=bunch_separation, rep_rate_trains=rep_rate_trains)
        
        self.length = length
        self.energy = energy
        self.charge = charge
        self.accel_gradient = accel_gradient
        self.wallplug_efficiency = wallplug_efficiency
        
        self.x_offset = x_offset
        self.y_offset = y_offset
        self.x_angle = x_angle
        self.y_angle = y_angle

        self.norm_jitter_emittance_x = norm_jitter_emittance_x
        self.norm_jitter_emittance_y = norm_jitter_emittance_y
        
        self.waist_shift_x = waist_shift_x
        self.waist_shift_y = waist_shift_y
        
        self.jitter = SimpleNamespace()
        self.jitter.x = 0
        self.jitter.y = 0
        self.jitter.z = 0
        self.jitter.t = 0
        self.jitter.xp = 0
        self.jitter.yp = 0
        self.jitter.E = 0

        self.spin_polarization = 0
        self.spin_polarization_direction = 'z'

        self.is_polarized = False #TODO shouldn't this rather be a function that checks whether spin_polarization > 0?
    
    
    @abstractmethod
    def track(self, beam, savedepth=0, runnable=None, verbose=False):
        """
        Add offsets and jitters to a ``beam`` generated by a ``Source`` 
        subclass' ``track()``. Also set the bunch train pattern, spin 
        polarization and various meta data to ``beam``. 
        """
        
        # add offsets and angles and jitter (horizontal)
        if self.norm_jitter_emittance_x is not None:
            # Sample a value from a jitter phase space
            x_jitter, xp_jitter = generate_trace_space(self.norm_jitter_emittance_x/beam.gamma(), beam.beta_x(), beam.alpha_x(), N=1, symmetrize=False)
        else:
            x_jitter, xp_jitter = np.random.normal(scale=self.jitter.x), np.random.normal(scale=self.jitter.xp)
        beam.set_xs(beam.xs() + self.x_offset + x_jitter)
        beam.set_xps(beam.xps() + self.x_angle + xp_jitter)
        
        if self.norm_jitter_emittance_y is not None:
            # Sample a value from a jitter phase space
            y_jitter, yp_jitter = generate_trace_space(self.norm_jitter_emittance_y/beam.gamma(), beam.beta_y(), beam.alpha_y(), N=1, symmetrize=False)
        else:
            y_jitter, yp_jitter = np.random.normal(scale=self.jitter.y), np.random.normal(scale=self.jitter.yp)
        beam.set_ys(beam.ys() + self.y_offset + y_jitter)
        beam.set_yps(beam.yps() + self.y_angle + yp_jitter)

        # shift the waist location
        beam.set_xs(beam.xs()-self.waist_shift_x*beam.xps())
        beam.set_ys(beam.ys()-self.waist_shift_y*beam.yps())
        
        # add longitudinal and energy jitter
        if abs(self.jitter.t) > 0:
            self.jitter.z = self.jitter.t*SI.c
        beam.set_zs(beam.zs() + np.random.normal(scale=self.jitter.z))
        beam.set_Es(beam.Es() + np.random.normal(scale=self.jitter.E))

        # set the bunch train pattern
        if self.num_bunches_in_train is not None:
            beam.num_bunches_in_train = self.num_bunches_in_train
        if self.bunch_separation is not None:
            beam.bunch_separation = self.bunch_separation

        # set spin polarization
        beam.set_arbitrary_spin_polarization(self.spin_polarization, direction=self.spin_polarization_direction)
        
        # set metadata
        beam.location = 0
        beam.stage_number = 0
        beam.trackable_number = -1
        
        return super().track(beam, savedepth, runnable, verbose)

    
    def get_length(self):
        if self.accel_gradient is not None:
            return self.energy/self.accel_gradient
        else:
            return self.length

    
    def get_cost_breakdown(self):
        if self.is_polarized:
            if self.charge < 0:
                return ('Polarized electron source', CostModeled.cost_per_source_polarized_electrons)
            else:
                return ('Polarized positron source', CostModeled.cost_per_source_polarized_positrons)
        else:
            return ('Source', CostModeled.cost_per_source)
        
        
    def get_energy(self):
        """
        Get the nominal mean beam particle energy. Alias for self.energy.
        """
        return self.energy

    def get_nom_energy(self):
        """
        Get the nominal mean beam particle energy. Alias for self.energy.
        """
        return self.get_energy()
    
    def energy_efficiency(self):
        return self.wallplug_efficiency
    
    def get_charge(self):
        """
        Get the total beam charge. Alias for self.charge.
        """
        return self.charge
    
    def get_average_beam_current(self):
        if self.get_rep_rate_average() is not None:
            return self.get_charge() * self.get_rep_rate_average()
    
    def energy_usage(self):
        return self.get_energy()*abs(self.get_charge())/self.energy_efficiency()

    def wallplug_power(self):
        if self.rep_rate is not None:
            return self.energy_usage() * self.rep_rate
    
    def survey_object(self):
        npoints = 10
        x_points = np.linspace(0, self.get_length(), npoints)
        y_points = np.linspace(0, 0, npoints)
        final_angle = 0 
        label = 'Source'
        color = 'black'
        return x_points, y_points, final_angle, label, color
        
    
    def print_summary(self):
        """
        Print a summary for the source.
        """
        print('Type: ', type(self))
        print('Number of macro particles: ', self.num_particles)
        print('Charge [nC]: ', self.charge*1e9)
        print('Energy [GeV]: ', self.energy/1e9)
        print('Normalised x emittance [mm mrad]: ', self.emit_nx*1e6)
        print('Normalised y emittance [mm mrad]: ', self.emit_ny*1e6)
        print('x beta function [mm]: ', self.beta_x*1e3)
        print('y beta function [mm]: ', self.beta_y*1e3)
        print('Relative energy spread [%]: ', self.rel_energy_spread*100)
        print('Bunch length [um]: ', self.bunch_length*1e6)
        #print('Gaussian blur [um]: ', self.gaussian_blur*1e6)
        #print('Current head [A]: ', self.current_head)
        print('x-offset [um]: ', self.x_offset*1e6)
        print('y-offset [um]: ', self.y_offset*1e6)
        print('z-offset [um]: ', self.z_offset*1e6)
        print('x-jitter [nm]: ', self.jitter.x*1e9)
        print('y-jitter [nm]: ', self.jitter.y*1e9)
        print('t-jitter [ns]: ', self.jitter.t*1e9)
        print('Normalised x emittance jitter [mm mrad]: ', 
            self.norm_jitter_emittance_x * 1e6 if self.norm_jitter_emittance_x is not None else "None")
        print('Normalised y emittance jitter [mm mrad]: ', 
            self.norm_jitter_emittance_y * 1e6 if self.norm_jitter_emittance_y is not None else "None")
        print('Symmetrisation: ', self.symmetrize)